###Names of all people who worked on the project
* Natalie Novitsky
* Alyssa Shin
* Tyler Meier
* Juliet Yznaga
* Tanvi Pabby

###Each person's role in developing the project:

Juliet: Data API, Exception Handling, Document Reading, Saving and Loading (Engines, Games, Profiles), Profile feature

Tyler: worked on player and all frontend, creating screens, styling, all UI stuff, and a little in controller dealing with functionality between the player and engine/data parts

Natalie: mainly Engine, Grid, Cell, UICell, GridCreator, GameProgressManager, and UserDefinedGame screens

Tanvi: worked primarily on the Engine part of the project (Validators, MatchFinders, Grid, Cell, ComponentCreator). Also worked on UserDefinedGames, and functionality between Player and Engine components.

Alyssa: worked on player and frontend, styling (css work), UI stuff, screen creation, grid/cell creation, sounds 

###What are the project's design goals, specifically what kinds of new features did you want to make easy to add

The main design goal of this project was to make adding additional games as uncomplicated and painless as possible. As we were evaluating the types of grid games we wanted to make, we noticed that some aspects of games were shared (such as selecting a given number of cells, checking whether those cells constituted a valid move, etc.). So, instead of creating a different class for every type of game, we created classes for the aspects of games. For example, each game has some kind of match validation. In Candy Crush or any Bejeweled game, match validation is done by comparing how many of the same type of cell surround it. Contrarily, a memory game checks to see if the state of two opened cells matches. We created a class for each type of validator so for every subsequent game that uses this same type of validation, we don’t have to rewrite any code. This makes it very easy to add new games and fairly simple to add games with different kinds of features. We just have to create a new object and necessary XML tags for this feature and implement it in our Engine logic. Additionally, along with facilitating the creation of new games, we wanted to provide a specialized user experience. Saving preferences, previous progress for a game and high scores were all features we hoped and were able to implement. To provide this experience, we designed an organized, simple structure for keeping track of profiles as well as using lambdas to update the backend data of a player written to XMLs every time a change occurred. 

###Describe the high-level design of your project, focusing on the purpose and interaction of the core classes

We separated our design into three parts: Player, Data and Engine. All of these ends communicated through the Controller which contains our main runnable method. In this approach, none of our ends (Data, Player and Engine) had to have instances of the others. All of the communication was done through the Controller at runtime which helped keep our program encapsulated. The Data end was responsible for reading and parsing all of the XML files. Data dealt with saving and loading of games as well as managed all of the action on the Profiles maintained in our game. The Data was responsible for passing on all of this information in a digestible form to the other ends. The Engine is responsible for the operation of the game. The Engine contains the logic for how each part of every game is played based on its tags (data in the XML files) and functioned to take in user moves and alter the board of the game.

Player class acted as our frontend and held all of the JavaFX, screens, visual elements of the gameplay and managed interaction with the user. To load a single game, all three ends came into play. The Controller would take the gametype from Player and hand it to Data to load. Data would then parse the engine attributes (constants for a given game like which Validator to use, number of cells selected per move, etc.), game attributes (details that vary level by level for a given game like size of the grid, target score, etc.) and initial configuration of the game. Controller would then hand this info to Engine which would build a game based on the parsed tags and establish a grid. From there, the backend Engine Grid was bound to a frontend grid so Grid updates would automatically be displayed without information having to be passed between the two ends with every move. The Player would add listeners to the “isOpen” property of cells (whether they were “face up”) and state property of cells to automatically update their ImageViews when either of these properties changed. With every move of the user, the engine automatically knows the clicking of the user (the “isSelected” property of cells can be toggled from the front end onClick and set back to unselected by the back end after a move is done) and is able to validate moves as well as change the board. Back end Properties to track whether the user has won or lost (or is still in game play) also have listeners in the front end to display the right screens when the game ends. Next levels are implemented similarly to the starting a game, but the Engine and Grid instances are maintained while the Grid and stats of the game are updated.

###What assumptions or decisions were made to simplify your project's design, especially those that affected adding required features

All games would be determined by a target score. All games would be lost by either running out of moves, lives, or time (each game has a different loss statistic). We also assumed that all of the games that used the OpenFinder class (bejeweled type games, and candy crush) would only classify a match as 3+ cells in a straight line (square does not count as a match).

One decision we chose to make in the frontend screens was sharing a pointer to the same UserProfile object that the backend also had. For simplicity, this really helped us in the project by allowing us to change things for the specific user profile as well as the backend/data when it needed to. It made the program much  easier to deal with and this specific task much easier. In terms of encapsulation, it may  not be the best  because it relies on both the frontend and the backend, however we thought that the pros of having the userprofile in the screens outweighed the cons of limited encapsulation, especially because of how efficiently it made updating user profiles.

Another decision that we made to make our project more flexible was to have each cell on the backend of the project (Engine) be represented as a UICell on the frontend (Player). This makes updating the grid that is being displayed, based on manipulations by Engine, much easier, as the states of the cells, and the open status of the cell are binded between frontend and backend, so there is little that needs to be done to ensure that the frontend grid is displaying changes that happen as a result of the player making moves in the game. This means that when there is a change in state in the backend, the frontend is automatically updated to reflect this change. This way of designing our project made it easier to add new features and games, as we knew that this method of updating the grid would work for any changes we planned on making.

Another decision we made to simplify adding new features/games was adding GridCreators to the project. This abstract class in the Engine part of the project allows for dynamic configuration of grids, so that if a new game, or level, is being added, a configuration does not need to be hard-coded for that game. This addition supports generating random configurations (which is best for candy crush, and bejeweled type games), pair configurations (best for memory-type games), as well as ‘neighbor’ configurations (which works well for the Minesweeper game).

###Describe, in detail, how to add new features to your project, especially ones you were not able to complete by the deadline

To add a new game to our project, first you need to create a default engine xml and default game xml which contains the necessary tags that correspond to your game. Next, you need to add this game into the resource bundle list of frontend games (and ensure it references a valid package of image files) and the default paths in the backend. After that, your game can be played! If you wanted to add a new type of feature to a game, such as a new type of PairValidator, you would have to create a new class that extends Validator. Since we use reflection, you would just need to specify this new type in the xml of your game and our Engine would be able to handle and apply it. If you wanted to make an entirely new type of feature, you have to integrate this feature into the main Engine class which handles overall game play, and make sure that by adding this you did not impede the play of existing games. You would also need to add this new tag to the resource bundle of either GameKeys or EngineKeys (depending on what the feature most pertained to) so our parser would be able to identify it in an xml file. This description is a bit vague because the steps to add a backend feature differ greatly depending on the feature. An example of a feature we added that utilized the flexibility of our program was adding automatic grid creators. We built three types: PairGridCreator (used for memory style games), RandomGridCreator (used for bejeweled style games), and NeighborGridCreator (for minesweeper style grids) and added the tag <GridCreator> to the engine attributes for each existing game. Then, we added a few lines in Engine and a method in ComponentCreator to use reflection to build the appropriate GridCreator subclass for a game. Finally, we added code in Engine to use the GridCreator to generate a grid if the initialConfig 2D array of initial states was null. 

To add a new type of attribute to a player profile, you would need to first add this new attribute as a field in the UserProfile class. You would then need to add this tag to the ProfileKeys resource bundle in the back end to make sure the Data knew to look for this new thing to parse. Next, you would need to implement getters, setters and any logic that needed to be performed on this attribute to the UserProfile class. If this is something that will be updated by the player at any point during game play (ex: high score, display preference etc. ) you would need to call save() within the setter method in order for the backend xml to be updated automatically every time that attribute was changed. Last, you would need to go into the XMLBuilder for an individual player and add lines to ensure that this tag is re-written back to the profile by calling createMapEntry() with appropriate parameters.

To  add a new color scheme or style to the UI, all you would need to do is create another CSS style sheet and then when you set the style, create another button in the  customize window that linked to that css sheet and everything would be updated. To add more screens, you would just need to create another class of whatever the screen is you want to be, and then have it extend superscreen (which deals with all of the basic instance variables for screens as well as some common methods shared amongst screens) and then add screen specific attributes to the class. Lastly, all of the texts in the frontend are taken from resource bundles, so new languages can easily be implemented by creating different properties files for different languages / other strings. The same can be said for images, as the image paths are taken from resource bundles.

